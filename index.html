<!DOCTYPE html>
<html>
<head>
    <title>Browser Extensions</title>
    <meta charset='utf-8'>
    <style>
        table, td, th {
            border: 1px solid black;
            padding: 8px;
            font-size: 11pt;
        }
        
        table {
            border-collapse: collapse;
        }
    </style>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
	shortName: "browserext",
	edDraftURI:"https://browserext.github.io/browserext/",

	specStatus: "CG-DRAFT",
	editors: [
	  {
	    name: "Mike Pietraszak",
	    company:"Microsoft Corporation"
	  }
	],

	wg: "Browser Extension Community Group",
	wgURI: "https://www.w3.org/community/browserext/",

	otherLinks: [{
	  key: 'Participation',
	  data: [
	    {
	      value: 'GitHub repository',
	      href: 'https://github.com/browserext/browserext/'
	    },
	    {
	      value: 'File a bug / view open issues',
	      href: 'https://github.com/browserext/browserext/issues'
	    }
	  ]
	}],
      };
    </script>
</head>
<body>
    <section id='abstract'>
        <p>
            Modern browsers can add new functionality to sites and the browser itself through
            script-based extensions. This document specifies an API set that allows developers
            to create interoperable extensions for browsers that support the API set,
            as well as the packaging format to be used for such extensions.
        </p>
    </section>
    <section id='sotd'>
        <p>
            If you wish to make comments regarding this document, please file issues on
            <a href="https://github.com/browserext/browserext/issues/">github</a>.
            A <a href="mailto:public-browserext@w3.org">public mailing list</a>
            (<a href="mailto:public-browserext-request@w3.org?subject=subscribe">subscribe</a>,
            <a href="http://lists.w3.org/Archives/Public/public-browserext/">archives</a>)
            is also available,
            but is reserved for high level discussions,
            and is not appropriate for specific comments about this document.
        </p>
        <p>
            Work on this document is governed by
            <a href="http://browserext.github.io/charter/">the charter</a> of the Browser Extension CG,
            which includes among other things the <a href="http://browserext.github.io/charter/#communication">Communication</a>,
            <a href="http://browserext.github.io/charter/#decision-policy">Decision</a>,
            and <a href="http://browserext.github.io/charter/#contribution-mechanics">Contribution</a> policies
            of this community group.
        </p>
    </section>

    <section class='informative'>
        <h2>Introduction</h2>
        <p>
            Because browsers supported different add-on models, extension authors wound up creating divergent codebases and delivering different browser-specific add-ons. This Community Group's goal is to make browser extension code much more interoperable across browsers by specifying common extension interfaces and well-defined browser behavior. This will allow extension authors to greatly reduce or eliminate the rework necessary to create extensions that target different browsers.
        </p>
    </section>

    <section >
        <h2>Core APIs</h2>
        <p>
            The goal for these core APIs is to provide functionality that extension authors need for: 
        </p>
        <p class="issue">Need to correct use of keywords from RFC 2119 https://dev.w3.org/2008/video/mediaann/ReSpec.js/documentation.html (MUST, MAY, SHALL, etc)</p>
        <p class="issue">Need to update &lt;section&gt; tags with appropriate class='informative' ("This section is non-normative.") usage. Some sections ARE normative, but the class tag remains due to cut-and-paste without appropriate clean-up by the Editor afterwards.</p>
        <ul>
            <li>page modification for web site content</li>
            <li>UI augmentation for web browsers (host apps)</li>
            <li>network request modification</li>
            <li>passing data between extensions</li>
            <li>passing data from Internet-hosted web pages to extensions</li>
            <li>accessing user settings such as bookmarks and cookies</li>
        </ul>
        <section class='informative'>
            <h3 id="apiavailability">API Availability</h3>
            <p>
                Browser extensions are authored primarily with JavaScript. In addition to the usual <a href="https://www.w3.org/standards/webdesign/script">JavaScript Web APIs</a>, additional APIs are available exclusively to extensions via the <code>browser</code> object. However, the specific APIs that are available to an extension from the <code>browser</code> object are dependent upon:
            </p>
            <ul>
                <li>Execution context (e.g. background/event, popup, options, content, extension page)
                <li>Keys declared in the manifest (e.g. browser_action, page_action)
                <li>Permissions declared in the manifest (e.g. contextMenu, tabs, webNavigation, webRequest)
                <li>Content Security Policy (CSP) for the extension and target web page (for content scripts)
            </ul>
            <section>
                <h4>Availability based on Content Security Policy (CSP)</h4>
                <p>
                    Use of some JavaScript APIs such as <code>eval()</code> are restricted due to CSP. If an explicit policy is not specified, the following default policy is applied.
                </p>
                <ul>
                    <li>Script execution via <code>eval()</code> and inline script execution are not allowed</li>
                    <li>Only script from the extension's package can be executed</li>
                    <li>Executing script from the web is not allowed</li>
                    <li>Content scripts are only allowed to inject script that executes immediately. Injected script that will only execute after an event-based delay is not permitted. Instead, content script must be used to handle non-immediate events.</li>
                </ul>
            </section>

            <section class="informative">
                <h4>Availability based on Execution Context</h4>
                <p>
                    Browser extension pages and their corresponding scripts are executed in one of the following contexts:
                </p>
                <ul>
                    <li><b>Browser extension contexts ("Window")</b> - Most extension APIs are available to this context
                        <ul>
                            <li><b>Background page</b> - use the "background" manifest key and specify "persistent" true </li>
                            <li><b>Event page</b> - use the "background" manifest key and specify "persistent" false </li>
                            <li><b>Popup page</b> - use the "browser_action" or "page_action" manifest key and specify "detault_popup" </li>
                            <li><b>Options page</b> - use the "options_page" manifest key </li>
                            <li><b>Custom page</b> - such as "browserext:&#x2F;&#x2F;&lt;ext_id&gt;&#x2F;myCustomPage.html" </li>
                        </ul>
                    </li>
                    <li><b>Content script context</b> - A limited number of APIs are available to script that extensions inject into hosted web site pages
                    <li><b>Internet-hosted web page context</b> - Messaging APIs can be used to send messages from hosted web site pages such as https://en.wikipedia.org/wiki/Main_Page/index.html or https://w3c.github.io/html/index.html to extensions
                </ul>
            </section>

            <section class="informative">
                <h4>Availability based on Manifest Keys and Permissions</h4>
                <p>
                    Some browser extension API require a specific manifest key or specific permission. If the key or permission are not declared or not granted, the object will not be available for scripting. These requirements are summarized in the table below.
                </p>
                <p class="issue">
                    DISCUSS: Should we remove the "Optional Permissions" column? Do we plan to support this in the common/core spec?
                </p>
                <table>
                    <tr>
                        <th rowspan=2>API object</th>
                        <th colspan=3>Execution Context</th>
                        <th colspan=2>Required Declaration</th>
                    </tr>
                    <tr>
                        <th>Background page,Event page,Popup page,Options page,Custom page</th>
                        <th>Content script page</th>
                        <th>Internet-hosted web page</th>
                        <th>Manifest key</th>
                        <th>Optional Permissions<sup><a href="#note2">2</a></sup></th>
                    </tr>
                    <tr>
                        <th><code>browserAction</code></th>
                        <td>Y<sup><a href="#note1">1</a></sup></td>
                        <td><p></p></td>
                        <td><p></p></td>
                        <td>"browser_action"<sup><a href="#note1">1</a></sup></td>
                        <td><p></p></td>
                    </tr>
                    <tr>
                        <th><code>contextMenus</code></th>
                        <td>Y</td>
                        <td><p></p></td>
                        <td><p></p></td>
                        <td>"permissions":["context_menus"]</td>
                        <td>Y<sup><a href="#note2">2</a></sup></td>
                    </tr>
                    <tr>
                        <th><code>extension</code></th>
                        <td>Y</td>
                        <td>Y</td>
                        <td><p></p></td>
                        <td><p></p></td>
                        <td><p></p></td>
                    </tr>
                    <tr>
                        <th><code>i18n</code></th>
                        <td>Y</td>
                        <td>Y</td>
                        <td><p></p></td>
                        <td>"default_lang" : "&lt;lang&gt;"<sup><a href="#note5">5</a></sup></td>
                        <td><p></p></td>
                    </tr>
                    <tr>
                        <th><code>pageAction</code></th>
                        <td>Y<sup><a href="#note1">1</a></sup></td>
                        <td><p></p></td>
                        <td><p></p></td>
                        <td>"page_action"<sup><a href="#note1">1</a></sup></td>
                        <td><p></p></td>
                    </tr>
                    <tr>
                        <th><code>runtime</code></th>
                        <td>Y</td>
                        <td>Y</td>
                        <td>Y<sup><a href="#note4">4</a></sup></td>
                        <td>“externally_connectable”:[...] <sup><a href="#note3">3</a></sup></td>
                        <td><p></p></td>
                    </tr>
                    <tr>
                        <th><code>tabs</code></th>
                        <td>Y</td>
                        <td><p></p></td>
                        <td><p></p></td>
                        <td>"permissions":["tabs","activeTab"]</td>
                        <td>Y<sup><a href="#note2">2</a></sup></td>
                    </tr>
                    <tr>
                        <th><code>webNavigation</code></th>
                        <td>Y</td>
                        <td><p></p></td>
                        <td><p></p></td>
                        <td>"permissions":["webNavigation"]</td>
                        <td>Y<sup><a href="#note2">2</a></sup></td>
                    </tr>
                    <tr>
                        <th><code>webRequest</code></th>
                        <td>Y</td>
                        <td><p></p></td>
                        <td><p></p></td>
                        <td>"permissions":["webRequest"]</td>
                        <td>Y<sup><a href="#note2">2</a></sup></td>
                    </tr>
                    <tr>
                        <th><code>windows</code></th>
                        <td>Y</td>
                        <td><p></p></td>
                        <td><p></p></td>
                        <td><p></p></td>
                        <td><p></p></td>
                    </tr>
                </table>
                <div id="note1" resource="#note1">
                    <sup>1</sup> Either <code>browserAction</code> or <code>pageAction</code> may be supported by an extension, not both
                </div>
                <div id="note2" resource="#note2">
                    <sup>2</sup> Note that some web browsers support the <code>browser.permissions</code> object. These web browsers can dynamically request that additional APIs be available if the user accepts a runtime request for these capabilities and their associated APIs. This dynamic capability is not supported in all web browsers.
                </div>
                <div id="note3" resource="#note3">
                    <sup>3</sup>Extensions may use the runtime object without declaring <code>"externally_connectable"</code> in the manifest. However, an extension may only receive messages sent from hosted web pages if this key is declared. It may also be used to block messages from other extensions, except for those in the <code>"ids"</code> list.
                </div>
                <div id="note4" resource="#note4">
                    <sup>4</sup>Internet-hosted web pages may send messages to extensions via runtime.sendMessage if the extension has explicitly specified the hosting site's domain in the manifest under the "externally_connectable" key.
                </div>
                <div id="note5" resource="#note5">
                    <sup>5</sup> Use of the <code>browser.i18n</code> object does not require a manifest permission declaration. However, the manifest does require a value (<code>default_locale</code>) that is necessary and cannot be specified by the extension author in script code. 
                </div>
            </section>

            <section >
                <h4 id="webidl">Expressing Availability in WebIDL</h4>
                <section>
                    <h4>Attribute: <code>Exposed</code></h4>
                    <p>
                        To express the aforementioned conditional situations in which certain APIs may or may not be available due to context, the following contexts are used:
                    </p>
                    <ul>
                        <li><b>Window</b> - The primary context for most browser extension APIs. This applies to background, event, popup, options and custom contexts</li>
                        <li><b>ContentScript</b> - Applies to content script context</li>
                    </ul>
                </section>
                <section>
                    <h4>Extended Attribute: <code>CheckAnyPermissions</code></h4>
                    <p>
                        To express the aforementioned conditional situations in which certain APIs may or may not be available due to expressed manifest keys or permissions, the new <a href="http://heycam.github.io/webidl/">WebIDL</a> extended attribute <code>"<a href="https://developer.mozilla.org/en-US/docs/Mozilla/WebIDL_bindings#CheckAnyPermissions">CheckAnyPermissions</a>"</code> is used.
                    </p>
                    <table>
                        <tr><td><b>API object</b></td><td><b>CheckAnyPermissions Value</b></td><td><b>Manifest Key or Value</b></td></tr>
                        <tr><td>browser</td><td>"browserextensions"</td><td>N/A</td></tr>
                        <tr><td>browser.browserAction</td><td>"browserAction"</td><td>"browserAction":[...]</td></tr>
                        <tr><td>browser.contextMenu</td><td>"contextMenus"</td><td>"permissions":["contextMenus"]</td></tr>
                        <tr><td>browser.extension</td><td>"browserextensions"</td><td><p></p></td></tr>
                        <tr><td>i18n</td><td>"browserextensions"</td><td>"default_language": "&lt;code&gt;"</td></tr>
                        <tr><td>pageAction</td><td>"pageAction"</td><td>"pageAction":[...]</td></tr>
                        <tr><td>runtime</td><td>"browserextensions"</td><td><p></p></td></tr>
                        <tr><td>tabs</td><td>"tabs"</td><td>"permissions":["tabs"] or<br/>"permissions":["activeTab"]</td></tr>
                        <tr><td>webNavigation</td><td>"webNavigation"</td><td>"permissions":["webNavigation"]</td></tr>
                        <tr><td>webRequest</td><td>"webRequest"</td><td>"permissions":["webRequest"]</td></tr>
                        <tr><td>windows</td><td>"browserextensions"</td><td><p></p></td></tr>

                    </table>
                </section>
                <section class="example">
                    <h4>Example: <code>browser.i18n</code></h4>
                        <p>
                            In this example, the <code>i18n</code> API should be made available to both browser host scripts (background, event, popup, options, etc.) and content scripts. Use of this API does not require a manifest permission declaration. Additionally, however, the manifest does require a value (<code>default_locale</code>) that is necessary and cannot be specified by the extension author in script code. This is expressed as a <code>BrowserExtensionManifest</code> dictionary.
                        </p>
                    <ol>
                        <li>
                            First, declare the methods for the <code>browser.i18n</code> object. 
                        </li>
                        <pre class="def idl">
                            [NoInterfaceObject]
                            interface BrowserI18n {
                              DOMString getMessage(DOMString messageName, sequence<DOMString>? substitutions);
                            };
                        </pre>
                        <li>
                            Next, we specify the available contexts ("Window" for background/event/popup/options...) and "ContentScript" for the content context.
                        </li>
                        <pre class="def idl">
[NoInterfaceObject, Exposed=(Window,ContentScript)] 
interface BrowserI18nAPI {
    readonly attribute BrowserI18n i18n;
}
                        </pre>
                        <li>
                            Connect the <code>i18n</code> object to the <code>browser.*</code> object.
                        </li>
                        <pre class="def idl">
                            Browser implements BrowserI18nAPI;
                        </pre>
                        <li>
                            Finally, we express the locale from manifest.json. For example <code>"default_locale": "en"</code>
                        </li>
                        <pre class="def idl">
                        partial dictionary BrowserExtensionManifest {
                          DOMString? defaultLocale;
                        };
                        </pre>
                    </ol>
                </section>
            </section>

        </section>

        <section>
            <h3>Events</h3>
            <p>
                Extension events are similar to DOM Events [<a href="https://www.w3.org/TR/dom/">DOM4</a>]. However, extension events are dispatched only to objects in the relevant extension scope (background, event, options, content, etc.). Script in the extension scope can observe events by calling <code>addListener()</code>.
            </p>
            <p class="issue">Should there be a readonly attribute EventListener onClicked?</p>
            <pre class="def idl">
[NoInterfaceObject, Exposed=(Window,ContentScript), CheckAnyPermissions="browserextensions"]
dictionary Rule {
    DOMString id;
    sequence&lt;DOMString&gt; tags;
    sequence&lt;Any&gt; conditions;
    sequence&lt;Any&gt; actions;
    unsigned short priority;
}
[NoInterfaceObject, Exposed=(Window,ContentScript), CheckAnyPermissions="browserextensions"]
interface BrowserExtensionEvent {
    void    addListener(Function callback);
    void    removeListener(Function callback);
    boolean hasListener(Function callback);
    boolean hasListeners();
}
</pre>
        </section>

        <section>
            <h3 id="coreapis">The <code>browser</code> object</h3>
                <section class="introductory"><h4>Overview</h4>
                    <p>
                        The core Browser Extension API objects are accessible from the <code>browser</code> object. Their availability varies, depending on conditions outlined in the <a href="#apiavailability">API Availability</a> section.
                    </p>
                    <ul>
                        <li>browserAction</li>
                        <li>contextMenus</li>
                        <li>extension</li>
                        <li>i18n</li>
                        <li>pageAction</li>
                        <li>runtime</li>
                        <li>tabs</li>
                        <li>webNavigation</li>
                        <li>webRequest</li>
                        <li>windows</li>
                    </ul>
                </section>
                <section class="introductory"><h4>Context</h4> 
                    <p>
                        This API is available in Window context (background, event, popup, options and custom pages), Content Script context, and Internet-hosted web page context.
                    </p>
                </section>
                <section class="introductory">
                    <h4>WebIDL Definition</h4>
                    <p>
                        A description of the special <a href="#webidl">WebIDL syntax considerations</a> for browser extensions are defined elsewhere in this document.
                    </p>
<pre class="def idl">
[CheckAnyPermissions="browserextensions"]
interface ExtensionGlobal {
    readonly attribute Browser browser;
};

Window implements ExtensionGlobal;

[NoInterfaceObject] 
interface Browser { // Should this be typed?
};

dictionary BrowserExtensionIcon {
    DOMString path;
    DOMString size;
};

typedef sequence&lt;BrowserExtensionIcon&gt; BrowserExtensionIconArray;

dictionary Developer {
    DOMString name;
    DOMString? url;
};

dictionary BrowserOrPageAction {
    BrowserExtensionIcon defaultIcon; 
    DOMString defaultPopup;
    DOMString defaultTitle;
};

dictionary KeyValue {
    DOMString key;
    DOMString? value;
};

dictionary BrowserSpecificSettings {
    DOMString browserName;
    sequence&lt;KeyValue&gt; keyValue;
};

dictionary BackroundOrEvent {
    DOMString page;
    boolean persistent;
    sequence&lt;DOMString&gt; scripts;
};

dictionary ContentScripts {
    boolean allFrames;
    sequence&lt;DOMString&gt; css;
    sequence&lt;DOMString&gt; excludeMatches;
    sequence&lt;DOMString&gt; js;
    sequence&lt;DOMString&gt; matches;
    DOMString runAt;
};

dictionary BrowserExtensionManifest {
    Background background;
    BrowserAction browserAction;
    BrowserSpecificSettings browserSpecificSettings;
    ContentScripts contentScripts;
    DOMString contentSecurityPolicy;
    DOMString defaultLocale;
    DOMString? description;
    Developer developer;
    BrowserExtensionIconArray icons;
    DOMString optionsPage;
    unsigned short manifestVersion;
    DOMString name;
    BrowserOrPageAction pageAction;
    sequence&lt;DOMString&gt; permissions;
    sequence&lt;DOMString&gt; requiredKeys;
    DOMString version;
    sequence&lt;DOMString&gt; webAccessibleResources;
};
</pre>
                </section> 

            <section>
                <h4 id="browserAction">The <code>browserAction</code> object</h4>
                <section class="introductory"><h4>Overview</h4>
                The <code>browserAction</code> object adds an always-visible button to the browser application, usually near the top of the browser application UI in the toolbar area. An extension may have either a <code>browserAction</code> or a <code>pageAction</code>, but not both.
                </section>
                <section class="introductory"><h4>Manifest</h4>
                    The <code>"browser_action"</code> and <code>"default_title"</code> keys are required. The other keys are optional.
<pre>
"browser_action": {                               // Required
    "default_icon": {...},                        // Same format as "icons"
    "default_popup": "Page URL",                  // Optional
    "default_title": "Title string"               // Required
}
</pre>
                </section>
                <section class="introductory"><h4>Context</h4>
                    <p>
                        This API is available in Window context (background, event, popup, options and custom pages).
                    </p>
                </section>
                <section class="introductory"><h4>WebIDL Definition</h4>
                    <p>
                        A description of the special <a href="#webidl">WebIDL syntax considerations</a> for browser extensions are defined elsewhere in this document.
                    </p>
                    <p class="issue">Should we standardize the spec to use "...Details" or "...Object" or "...Data" or "...Info" for objects used to specify parameter objects?</p>
                    <p class="issue">Should we prefix object names with "Browser..." or "BrowserExt..." or "&lt;Object&gt;..." (e.g. "Tabs...")?</p>
                    <p class="issue">Need to find all strings that support null and add ? to DOMString (DOMString?).</p>
<pre class="def idl">
dictionary BrowserActionDefaults {
    BrowserExtensionIconArray defaultIcon;
    DOMString? defaultPopup;
    DOMString  defaultTitle;
};

partial dictionary BrowserExtensionManifest {
    BrowserActionDefaults? browserAction;
};

typedef sequence&lt;unsigned short&gt; ColorArray;

dictionary TabIdDetailsObject {
    unsigned short tabId;
};

dictionary BadgeObjectColorArrayTabId {
    ColorArray color;
    unsigned short tabId;
};

dictionary BadgeObjectTextTabId {
    unsigned short tabId;
    DOMString text;
};

dictionary BadgeObjectPathTabId {
    DOMString path;
    unsigned short tabId;
};

dictionary BadgeObjectTabIdPopup {
    DOMString popupHTMLFileName;
    unsigned short tabId;
};

callback BrowserActionGetBadgeBackgroundColorCallback = void (ColorArray result);
callback BrowserActionGetBadgeTextCallback = void (DOMString result);
callback BrowserActionGetPopupCallback = void (DOMString result);
callback BrowserActionOnClickedCallback = void (TabsTab tab);
callback BrowserActionSetIconCallback = void ();

[NoInterfaceObject]
interface BrowserBrowserAction {
    void disable(unsigned short tabId);
    void enable(unsigned short tabId);
    void getBadgeBackgroundColor(TabIdDetailsObject details, BrowserActionGetBadgeBackgroundColorCallback callback);
    void getBadgeText(TabIdDetailsObject details, BrowserActionGetBadgeTextCallback callback);
    void getPopup(TabIdDetailsObject details, BrowserActionGetPopupCallback callback);
    BrowserExtensionEvent onClicked(BrowserActionOnClickedCallback callback);
    void setBadgeBackgroundColor(BadgeObjectColorArrayTabId details);
    void setBadgeText(BadgeObjectTextTabId details);
    void setIcon(BadgeObjectPathTabId data, BrowserActionSetIconCallback callback);
    void setPopup(BadgeObjectTabIdPopup details);
};

[NoInterfaceObject, Exposed=Window, CheckAnyPermissions="browserAction"]
interface BrowserBrowserActionAPI {
    readonly attribute BrowserBrowserAction browserAction; 
};

Browser implements BrowserBrowserActionAPI;
</pre>
                </section>
            </section>


            <section>
                <h4 id="contextMenus">The <code>contextMenus</code> object</h4>
                <section class="introductory"><h4>Overview</h4>
                    <p>
                        The <code>contextMenus</code> object allows additional entries to be added to the browser's context menu. The menu may selectively be shown for various browser UI elements (browser action or page action button) or page elements (frame, image, link, page, selection, etc.).
                    </p>
                </section><section class="introductory"><h4>Manifest</h4>
                    <p>
                        A <code>"contextMenus"</code> entry must be declared in the <code>"permissions"</code> key. The icon keys are optional.
                    </p>
<pre>
"permissions": [                                  // Required
    "contextMenus"                                // Required
],                                                // Required
"icons": {                                        // Optional
    "&lt;size&gt;":"&lt;name.png&gt;"                         // Optional, size 16 recommended
}                                                 // Optional
</pre>
                </section><section class="introductory"><h4>Context</h4>
                    <p>
                        This API is available in Window context (background, event, popup, options and custom pages).
                    </p>
                </section><section class="introductory"><h4>WebIDL Definition</h4>
                    <p>
                        A description of the special <a href="#webidl">WebIDL syntax considerations</a> for browser extensions are defined elsewhere in this document.
                    </p>
                     
<pre class="def idl">
enum ContextType { "all", "audio", "browser_action", "editable", "frame", "image", "link", "page", "page_action", "selection", "video" };

enum ItemType { "checkbox","normal","radio","separator" };

dictionary ContextMenuCreateProperties {
    boolean checked;
    boolean enabled;
    sequence&lt;DOMString&gt; documentUrlPatterns;
    sequence&lt;ContextType&gt; contexts;
    DOMString id;
    (unsigned short or DOMString) parentId;
    Function onclick;
    sequence&lt;DOMString&gt; targetUrlPatterns;
    DOMString title;
    DOMString type;
};

dictionary ContextMenuUpdateProperties {
    boolean checked;
    sequence&lt;ContextType&gt; contexts;
    sequence&lt;DOMString&gt; documentUrlPatterns;
    boolean enabled;
    Function onclick;
    unsigned short parentId;
    sequence&lt;DOMString&gt; targetUrlPatterns;
    DOMString title;
    ItemType type;
};

callback ContextMenuCreateCallback = void ();
callback ContextMenuOnClickedCallback = void (ContextMenuOnClickedInfo info, TabsTab tab);
callback ContextMenuOnUpdateCallback = void ();
callback ContextMenuOnRemoveCallback = void ();
callback ContextMenuOnRemoveAllCallback = void ();

[NoInterfaceObject]
interface BrowserContextMenus {
    unsigned short create(ContextMenuCreateProperties data, optional ContextMenuCreateCallback callback);
    object onClicked(Function callback);
	void remove((unsigned short or DOMString) itemId, optional ContextMenuOnRemoveCallback callback);
	void removeAll(optional ContextMenuOnRemoveAllCallback callback);
	void update((unsigned short or DOMString) itemId, ContextMenuUpdateProperties data, optional ContextMenuOnUpdateCallback callback);
};

[NoInterfaceObject, Exposed=Window, CheckAnyPermissions="contextMenus"]
interface BrowserContextMenusAPI {
    readonly attribute BrowserContextMenus contextMenus; 
};

Browser implements BrowserContextMenusAPI;
</pre>
                </section>
            </section>

            <section>
                <h4 id="extension">The <code>extension</code> object</h4>
                <section class="introductory"><h4>Overview</h4>
                <p class="issue">TODO: Do we really need this object? Can we just support runtime?</p>
                    <p>
                        The <code>extension</code> object provides a way to determine the absolute path to extension resources (e.g. browserext://&lt;ext_id&gt;/options.html) or access the background page's <code>window</code> object.
                    </p>
                </section><section class="introductory"><h4>Manifest</h4>
                    <p>
                        There are no additional manifest entries required to use this object.
                    </p>
                </section><section class="introductory"><h4>Context</h4>
                    <p>
                        This API is available in Window context (background, event, popup, options and custom pages) and Content Script context.
                    </p>
                </section><section class="introductory"><h4>WebIDL Definition</h4>
                    A description of the special <a href="#webidl">WebIDL syntax considerations</a> for browser extensions are defined elsewhere in this document.
                     
<pre class="def idl">    
[NoInterfaceObject]
interface BrowserExtension {
    DOMString getURL(DOMString path);
    Window getBackgroundPage();
};

[NoInterfaceObject, Exposed=Window, CheckAnyPermissions="browserextensions"]
interface BrowserExtensionAPI {
    readonly attribute BrowserExtension extension; 
};

Browser implements BrowserExtensionAPI;
</pre>
                </section>
            </section>


            <section>
                <h4 id="i18n">The <code>i18n</code> object</h4>
                <section class="introductory"><h4>Overview</h4>
                    <p>
                        The <code>i81n</code> object provides a way to access strings that have been localized into supported languages.
                    </p>
                </section>
                <section class="introductory"><h4>Manifest</h4>
                    <p>
                        When providing localized strings, you must specify a default locale using a two-character code. Codes can be found at <a href="http://www.w3.org/TR/1999/REC-html401-19991224/struct/dirlang.html">RFC1766</a> or <a href="http://www.w3.org/International/articles/language-tags/">IETF BCP47</a>. To manifest localize strings, the syntax below may be used.
                    </p>
<pre>
"default_locale" : "&lt;twoCharLocaleCode&gt;",              // Required
"name" : "__MSG_&lt;yourCustomNameStringIdentifier&gt;__",
"description" : "__MSG_&lt;yourCustomDescriptionStringIdentifier&gt;__",
</pre>
                For example
                <pre>
"default_locale" : "en",              // English
"name" : "__MSG_MySampleExtension__",
"description" : "__MSG_MySampleExensionDecription__",
</pre>
                </section>
                <section class="introductory"><h4>Localized Strings</h4>
                    <p>
                        Each supported locale must have its own <code>messages.json</code> file stored in the folder <code>_locales/&lt;twoCharLocaleCode&gt;</code>. The two-character codes used for directory names here the same as are used in the <code>mainfest.json</code> to specify <code>default_locale</code>.
                    </p>
                </section>
                <section class="introductory"><h4>messages.json Syntax</h4>
                    <p class="issue">TODO: The requirements for the messages.json file will be described here.</p>
                </section><section class="introductory"><h4>String Patterns</h4>
                    <p class="issue">TODO: Define insertions, @@patterns, etc...</p>
                </section><section class="introductory">
                    <h4>Context</h4>
                    <p>
                        This API is available in Window context (background, event, popup, options and custom pages) and Content Script context.
                    </p>
                </section><section class="introductory"><h4>WebIDL Definition</h4>
                    <p>
                        A description of the special <a href="#webidl">WebIDL syntax considerations</a> for browser extensions are defined elsewhere in this document.
                    </p>
                     
<pre class="def idl">    
[NoInterfaceObject]
interface BrowserI18n {
    DOMString getMessage(DOMString messageName, sequence<DOMString>? substitutions);
};

[NoInterfaceObject, Exposed=(Window,ContentScript), CheckAnyPermissions="browserextensions"] 
interface BrowserI18nAPI {
        readonly attribute BrowserI18n i18n;
};

Browser implements BrowserI18nAPI;

partial dictionary WebExtensionManifest {
    DOMString? defaultLocale;
};

</pre>
                </section>
            </section>

            <section>
                <h4 id="pageAction">The <code>pageAction</code> object</h4>
                <section class="introductory"><h4>Overview</h4>
                    <p>
                        The <code>pageAction</code> object adds a button to the browser application, usually within the address bar. This button typically appears only when the extension has detected that it can perform an action on the current page for the active tab. An extension may have either a <code>browserAction</code> or a <code>pageAction</code>, but not both.
                    </p>
                </section><section class="introductory"><h4>Manifest</h4>
                    <p>
                        The <code>"page_action"</code> and <code>"default_title"</code> keys are required. The other keys are optional.
                    </p>
<pre>
"page_action": {                               // Required
    "default_icon": {...},                        // Same format as "icons"
    "default_popup": "Page URL",                  // Optional
    "default_title": "Title string"               // Required
}
</pre>
                </section>
                <section class="introductory">
                    <h4>Context</h4>
                    <p>
                        This API is available in Window context (background, event, popup, options and custom pages).
                    </p>
                </section>
                <section class="introductory"><h4>WebIDL Definition</h4>
                    <p>
                        A description of the special <a href="#webidl">WebIDL syntax considerations</a> for browser extensions are defined elsewhere in this document.
                    </p>
                     
<pre class="def idl">
dictionary PageActionDefaults {
    BrowserExtensionIconArray defaultIcon;
    DOMString? defaultPopup;
    DOMString  defaultTitle;
};

partial dictionary BrowserExtensionManifest {
    PageActionDefaults? pageAction;
};

dictionary BadgeObjectPath {
    DOMString path;
};

callback PageActionGetPopupCallback = void (DOMString result);
callback PageActionGetTitleCallback = void (DOMString result);
callback PageActionOnClickedCallback = void (TabsTab tab);
callback PageActionSetIconCallback = void ();

interface BrowserPageAction {
    void getPopup(TabIdDetailsObject details, PageActionGetPopupCallback callback);
    void getTitle(TabIdDetailsObject details, PageActionGetTitleCallback callback);
    void hide(unsigned short tabId);
    BrowserExtensionEvent onClicked(PageActionOnClickedCallback callback);
    void setIcon(BadgeObjectPath details, optional PageActionSetIconCallback callback);
    void setPopup(BadgeObjectPathTabId details);
    void setTitle(BadgeObjectTextTabId details);
    void show(unsigned short tabId);
};

[NoInterfaceObject, Exposed=Window, CheckAnyPermissions="pageAction"]
interface BrowserPageActionAPI {
    readonly attribute BrowserPageAction pageAction; 
};

Browser implements BrowserPageActionAPI;
</pre>
                </section>
            </section>

            <section>
                <h4 id="runtime">The <code>runtime</code> object</h4>
                <section class="introductory"><h4>Overview</h4>
                    <p>
                        The <code>runtime</code> object is used to send and receive messages across contexts, as well as access extension-level information such as the id, manifest, and absolute path to resources.
                    </p>
                </section><section class="introductory"><h4>Manifest</h4>
                    <p>
                        There are no additional manifest entries required for an extension to use this object. However, an extension may only receive messages sent from hosted web pages if the “externally_connectable” key is declared. Also, an extension may block messages from other extensions by specifying only approved extensions. Note that if this key is used to allow web pages to send messages, unless <code>"ids" : ["*"]</code> is specified, all messages from other extensions will be blocked. URLs in the <code>"matches"</code> array must include a top-level domain. This list does not affect content scripts.
                    </p>
<pre>
"externally_connectable" : [
    "ids":[...], // Identifiers for other extensions that are allowed to send messages
    "matches":[...] // URL patterns for hosted web pages allowed to send messages 
    ]
</pre>
                </section>
                <section class="introductory">
                    <h4>Context</h4>
                    <p>
                        This API is available in Window context (background, event, popup, options and custom pages), Content Script context, and Internet-hosted web page context.
                    </p>
                </section>
                <section class="introductory"><h4>WebIDL Definition</h4>
                    <p>
                        A description of the special <a href="#webidl">WebIDL syntax considerations</a> for browser extensions are defined elsewhere in this document.
                    </p>
                     
<pre class="def idl">
dictionary RuntimePort {
    Function disconnect;
    DOMString name;
    object onDisconnect;
    object onMessage;
    Function postMessage;
    MessageSender sender;
};

dictionary RuntimeMessageSender {
    DOMString id;
    unsigned short frameId;
    TabObject tab;
    DOMString url;
};

callback RuntimeOnConnectCallback = void (RuntimePort port);
callback RuntimeSendResponseCallback = void ();
callback RuntimeOnMessageCallback = void (optional any message, RuntimeMessageSender sender, RuntimeSendResponseCallback callback);
callback RuntimeSendMessageCallback = void (any response);

[NoInterfaceObject]
interface BrowserRuntime {
    object getManifest();
    DOMString getURL(DOMString path);
    DOMString id;
    void onConnect(RuntimeOnConnectCallback callback);
    void onMessage(RuntimeOnMessageCallback callback);
    void sendMessage(optional DOMString extensionId, any message, optional RuntimeSendMessageCallback callback);
    RuntimePort Port;
    RuntimeMessageSender MessageSender;
};

[NoInterfaceObject, Exposed=Window, CheckAnyPermissions="browserextensions"]
interface BrowserRuntimeAPI {
    readonly attribute BrowserRuntime runtime; 
};

Browser implements BrowserRuntimeAPI;
</pre>
                </section>
            </section>

            <section>
                <h4 id="tabs">The <code>tabs</code> object</h4>
                <section class="introductory"><h4>Overview</h4>
                    <p>
                        The <code>tabs</code> object is used to access metadata about a tab, such as its title, or to access the current content within the tab itself.
                    </p>
                </section><section class="introductory"><h4>Manifest</h4>
                    <p>
                        The <code>"tabs"</code> permission is required to use this object.
                    </p>
<pre>
{
    "permissions": [                               // Required
        "tabs"                                     // Either "tabs" or "activeTab" is required
        "activeTab"                                // Either "tabs" or "activeTab" is required
    ]                                              // Required   
}
</pre>
                </section>
                <section class="introductory">
                    <h4>Context</h4>
                    <p>
                        This API is available in Window context (background, event, popup, options and custom pages).
                    </p>
                </section>
                <section class="introductory"><h4>WebIDL Definition</h4>
                    <p>
                        A description of the special <a href="#webidl">WebIDL syntax considerations</a> for browser extensions are defined elsewhere in this document.
                    </p>
                     
<pre class="def idl">
dictionary TabsTab {
    boolean active;
    boolean audible;
    DOMString favIconUrl;
    boolean highlighted;
    unsigned short height;
    unsigned short id;
    boolean incognito;
    unsigned short index;
    TabMutedInfo mutedInfo;
    unsigned short openerTabId;
    boolean pinned;
    DOMString sessionId;
    DOMString status;
    DOMString title;
    DOMString url;
    unsigned short width;
    unsigned short windowId;
};

enum TabMutedReasonInfo { "user", "capture", "extension" };

dictionary TabMutedInfo {
    DOMString extensionId;
    boolean muted;
    TabMutedReasonInfo reason;
};

dictionary TabConnectObject {
    unsigned short frameId;
    DOMString name;
};

dictionary TabCreateProperties {
    boolean active;
    unsigned short index;
    unsigned short openerTabId;
    boolean pinned;
    DOMString url;
    unsigned short windowId;
};

enum RunAt { "document_end", "document_idle", "document_start" };

dictionary TabScriptAndCSSDetails {
    boolean allFrames;
    DOMString code;
    DOMString file;
    unsigned short frameId;
    boolean matchAboutBlank
    RunAt runAt;
};

enum TabStatus { "complete", "loading" };

enum WindowTypes { "app", "normal", "panel", "popup" };

dictionary TabQueryInfo {
    boolean active;
    boolean audible;  
    boolean currentWindow;
    boolean highlighted;
    unsigned short index;
    boolean lastFocusedWindow;
    boolean muted;
    boolean pinned;
    TabStatus status;
    DOMString title;
    (DOMString or sequence&lt;DOMString&gt;) url;
    unsigned short windowId;
    WindowType windowType;
};

dictionary TabReloadProperties {
    boolean bypassCache;
};

dictionary TabSendMessageOptions {
    unsigned short frameId;
};

dictionary TabUpdateProperties {
    boolean active;
    boolean highlighted;
    boolean muted;
    unsigned short openerTabId;
    boolean pinned;
    DOMString url;
};

dictionary TabIdWindowId {
    unsigned short tabId;
    unsigned short windowId;
};

dictionary TabsWindowIdIsWindowClosing {
    boolean isWindowClosing;
    unsigned short tabId;
};

dictionary TabsOnUpdatedChangeInfo {
    boolean audible;    
    DOMString favIconUrl;
    TabMutedInfo mutedInfo;
    boolean pinned;
    DOMString status;
    DOMString title;
    DOMString url;
};

callback TabsCreateCallback = void (TabsTab tab);
callback TabsGetCallback = void (TabsTab tab);
callback TabsGetCurrentCallback = void (TabsTab tab);
callback TabsOnActivatedCallback = void (TabIdWindowId activeInfo);
callback TabsOnCreatedCallback = void (TabTab tab);
callback TabsOnRemovedCallback = void (TabsWindowIdIsWindowClosing removeInfo);
callback TabsOnUpdatedCallback = void (unsigned short tabId, TabsOnUpdatedChangeInfo changeInfo, TabsTab tab);
callback TabsQueryCallback = void (TabsTab tab);
callback TabsRemoveCallback = void ();
callback TabsSendMessageCallback = void (any response);
callback TabsUpdateCallback = void (TabsTab tab);

[NoInterfaceObject]
interface BrowserTabs {
    RuntimePort connect(unsigned short tabId, TabConnectInfo details);
    void create(TabCreateProperties details, optional TabsCreateCallback callback);
    void executeScript(unsigned short tabId, TabScriptAndCSSDetails details);
    void get(unsigned short tabId, TabsGetCallback callback);
    void getCurrent(TabsGetCurrentCallback callback);
    void insertCSS(unsigned short tabId, TabScriptAndCSSDetails details);
    void onActivated(TabsOnActivatedCallback callback);
    void onCreated(TabsOnCreatedCallback callback);
    void onRemoved(TabsOnRemovedCallback callback);
    void onUpdated(TabsOnUpdatedCallback callback);
    void query(TabQueryInfo queryInfo, TabsQueryCallback callback);
    void reload(TabReloadProperties details, Function callback);
    void remove((unsigned short or sequence&lt;unsigned short&gt;) tabIds, TabsRemoveCallback callback);
    void sendMessage(unsigned short tabId, any message, optional TabSendMessageOptions details, optional TabsSendMessageCallback callback);
    void update(optional unsigned short tabId, TabUpdateProperties details, optional TabsUpdateCallback callback);
};

[NoInterfaceObject, Exposed=Window, CheckAnyPermissions="tabs"]
interface BrowserTabsAPI {
readonly attribute BrowserTabs tabs; 
};

Browser implements BrowserTabsAPI;
</pre>
                </section>
            </section>


            <section>
                <h4 id="webNavigation">The <code>webNavigation</code> object</h4>
                <section class="introductory"><h4>Overview</h4>
                    <p>
                        The <code>webNavigation</code> object is used to monitor events related to networking requests.
                    </p>
                </section><section class="introductory"><h4>Manifest</h4>
                    <p>
                        The <code>"webNavigation"</code> permission is required to use this object.
                    </p>
<pre>
{
    "permissions": [                               // Required
        "webNavigation"                            // Required
    ]                                              // Required   
}
</pre>
                </section>
                <section class="introductory">
                    <h4>Context</h4>
                    <p>
                        This API is available in Window context (background, event, popup, options and custom pages).
                    </p>
                </section>
                <section class="introductory"><h4>WebIDL Definition</h4>
                    <p>
                        A description of the special <a href="#webidl">WebIDL syntax considerations</a> for browser extensions are defined elsewhere in this document.
                    </p>
                     
<pre class="def idl">
enum TransitionType { "link", "typed" };
dictionary WebNavigationOnBeforeNavigateDetails {
    unsigned short frameId;
    unsigned short parentFrameId;
    unsigned short tabId;
    double timeStamp;
    DOMString url;
};

dictionary WebNavigationOnCommittedDetails {
    unsigned short frameId;
    unsigned short processId;
    unsigned short tabId;
    double timeStamp;
    TransitionType transitionType;
    DOMString url;
};

dictionary WebNavigationOnCompletedDetails {
    unsigned short frameId;
    unsigned short processId;
    unsigned short tabId;
    double timeStamp;
    DOMString url;
};

dictionary WebNavigationOnDOMContentLoadedDetails {
    unsigned short frameId;
    unsigned short processId;
    unsigned short tabId;
    double timeStamp;
    DOMString url;
};

dictionary WebNavigationOnErrorOccurredDetails {
    DOMString error;
    unsigned short frameId;
    unsigned short tabId;
    double timeStamp;
    DOMString url;
};

dictionary WebNavigationOnReferenceFragmentUpdatedDetails {
    unsigned short frameId;
    unsigned short processId;
    unsigned short tabId;
    double timeStamp;                           
    TransitionType transitionType;
    DOMString url;
};

callback WebNavigationOnBeforeNavigateCallback = void (WebNavigationOnBeforeNavigateDetails details);
callback WebNavigationOnCommittedCallback = void (WebNavigationOnCommittedDetails details);
callback WebNavigationOnCompletedCallback = void (WebNavigationOnCompletedDetails details);
callback WebNavigationOnDOMContentLoadedCallback = void (WebNavigationOnDOMContentLoadedDetails details);
callback WebNavigationOnErrorOccurredCallback = void (WebNavigationOnErrorOccurredDetails details);
callback WebNavigationOnReferenceFragmentUpdated = void (WebNavigationOnReferenceFragmentUpdatedDetails details);

[NoInterfaceObject]
interface BrowserWebNavigation {
    void onBeforeNavigate(WebNavigationOnBeforeNavigateCallback callback);
    void WebNavigationOnCommittedCallback(WebNavigationOnCommittedCallback callback);
    void onCompleted(WebNavigationOnCompletedCallback callback);
    void onDOMContentLoaded(WebNavigationOnDOMContentLoadedCallback callback);
    void onErrorOccurred(WebNavigationOnErrorOccurredCallback callback);
    void onReferenceFragmentUpdated(WebNavigationOnReferenceFragmentUpdated callback);
};
    
[NoInterfaceObject, Exposed=Window, CheckAnyPermissions="webNavigation"]
interface BrowserWebNavigationAPI {
    readonly attribute BrowserWebNavigation webNavigation; 
};

Browser implements BrowserWebNavigationAPI;
</pre>
                </section>
            </section>


            <section>
                <h4 id="webRequest">The <code>webRequest</code> object</h4>
                <section class="introductory"><h4>Overview</h4>
                    <p>
                        The <code>webRequest</code> object is used to modify or cancel networking requests.
                    </p>
                </section><section class="introductory"><h4>Manifest</h4>
                    <p>
                        The <code>"webRequest"</code> permission is required to use this object.
                    </p>
<pre>
{
    "permissions": [                           // Required
        "webRequest"                            // Required
        "webRequestBlocking"                    // Optional
        "&lt;URL pattern&gt;"                         // Optional, e.g. "*://*.w3c.org/"
    ]                                          // Required   
}
</pre>
                </section>
                <section class="introductory">
                    <h4>Context</h4>
                    <p>
                        This API is available in Window context (background, event, popup, options and custom pages).
                    </p>
                </section>
                <section class="introductory"><h4>WebIDL Definition</h4>
                    <p>
                        A description of the special <a href="#webidl">WebIDL syntax considerations</a> for browser extensions are defined elsewhere in this document.
                    </p>
                    <p class="issue"><code>unsigned short</code> was used in many places in this spec to represent both unsigned integers and signed integers. Need to go back and find the places where negative numbers are allowed and changed from unsigned short to short.</p>
<pre class="def idl">
enum ResourceType { "main_frame", "sub_frame", "stylesheet", "script", "image", "font", "object", "xmlhttprequest", "ping", "other" };

dictionary WebRequestUploadData {
    any bytes;
    DOMString file;
};

dictionary WebRequestRequestBody {
    DOMString error;
    object formData;
    sequence&lt;WebRequestUploadData&gt; rawData;
};

dictionary WebRequestHttpHeader {
    DOMString keyName;
    any value;
};

dictionary WebRequestHttpHeaders {
    sequence&lt;WebRequestHttpHeader&gt; data; 
};

dictionary WebRequestOnBeforeRequestDetails {
    unsigned short frameId;
    DOMString method;
    unsigned short parentFrameId;
    WebRequestRequestBody requestBody;
    DOMString requestId;
    unsigned short tabId;
    double timeStamp;
    ResourceType type;
    DOMString url;
};

dictionary WebRequestOnBeforeSendHeadersDetails {
    unsigned short frameId;
    DOMString method;
    unsigned short parentFrameId;
    DOMString requestId;
    unsigned short tabId;
    double timeStamp;
    ResourceType type;
    DOMString url;
};

dictionary WebRequestOnCompletedDetails {
    unsigned short frameId;
    boolean fromCache;
    DOMString method;
    unsigned short parentFrameId;
    DOMString requestId;
    WebRequestHttpHeaders responseHeaders;
    DOMString serverIP;
    unsigned short statusCode;
    DOMString statusLine;
    unsigned short tabId;
    double timeStamp;   
    ResourceType type;
    DOMString url;
}; 

dictionary WebRequestOnHeadersReceivedDetails {
    unsigned short frameId;
    DOMString method;
    unsigned short parentFrameId;
    WebRequestHttpHeaders responseHeaders;
    DOMString requestId;
    unsigned short statusCode;
    DOMString statusLine;
    unsigned short tabId;
    double timeStamp;   
    ResourceType type;
    DOMString url;
};

dictionary WebRequestOnSendHeadersDetails {
    unsigned short frameId;
    DOMString method;
    unsigned short parentFrameId;
    WebRequestHttpHeaders requestHeaders;
    DOMString requestId;
    unsigned short tabId;
    double timeStamp;   
    ResourceType type;
    DOMString url;
};

callback WebRequestOnBeforeRequestCallback = void (WebRequestOnBeforeRequestDetails details);
callback WebRequestOnBeforeSendHeadersCallback = void (WebRequestOnBeforeSendHeadersDetails details);
callback WebRequestOnCompletedCallback = void (WebRequestOnCompletedDetails details);
callback WebRequestOnHeadersReceivedCallback = void (WebRequestOnHeadersReceivedDetails details);
callback WebRequestOnSendHeadersCallback = void (WebRequestOnSendHeadersDetails details);

[NoInterfaceObject]
interface BrowserWebRequest {
    void onBeforeRequest(WebRequestOnBeforeRequestCallback callback);
    void onBeforeSendHeaders(WebRequestOnBeforeSendHeadersCallback callback);
    void onCompleted(WebRequestOnCompletedCallback callback);
    void onHeadersReceived(WebRequestOnHeadersReceivedCallback callback);
    void onSendHeaders(Function callback);
};

[NoInterfaceObject, Exposed=Window, CheckAnyPermissions="webRequest"]
interface BrowserWebRequestAPI {
    readonly attribute BrowserWebRequest webRequest; 
};

Browser implements BrowserWebRequestAPI;
</pre>
                </section>
            </section>

            <section>
                <h4 id="windows">The <code>windows</code> object</h4>
                <section class="introductory"><h4>Overview</h4>
                    <p>
                        The <code>windows</code> object is used to access the UI windows managed by the browser.
                    </p>
                </section><section class="introductory"><h4>Manifest</h4>
                    <p>
                        There are no additional manifest entries required for an extension to use this object.
                    </p>
                </section>
                <section class="introductory">
                    <h4>Context</h4>
                    <p>
                        This API is available in Window context (background, event, popup, options and custom pages).
                    </p>
                </section>
                <section class="introductory"><h4>WebIDL Definition</h4>
                    <p>
                        A description of the special <a href="#webidl">WebIDL syntax considerations</a> for browser extensions are defined elsewhere in this document.
                    </p>
                     
<pre class="def idl">
enum WindowsWindowType { "detached_panel", "normal", "panel", "popup" };

enum WindowsWindowState { "docked", "fullscreen", "maximized", "minimized", "normal" };

dictionary CreateWindowInfo {
    boolean focused;
    unsigned short height;
    boolean incognito;
    unsigned short left;
    unsigned short tabId;
    unsigned short top;
    (DOMString or sequence&lt;DOMString&gt;) url;
    WindowsWindowState state;
    unsigned short width;
    WindowsWindowType windowType;
};

dictionary GetWindowInfo {
    boolean populate;
    sequence&lt;WindowTypes&gt; windowTypes;
};

dictionary WindowUpdateInfo {
    boolean drawAttention;
    boolean focused;
    unsigned short height;
    unsigned short left;
    unsigned short top;
    unsigned short width;
    WindowState windowState;
};

dictionary WindowsWindow = {
    boolean alwaysOnTop;
    boolean focused;
    unsigned short height;
    unsigned short id;
    boolean incognito;
    unsigned short left;
    sequence&lt;TabsTab&gt; tabs;
    unsigned short top;
    DOMString sessionId;
    WindowsWindowState state;
    unsigned short width;
    WindowsWindowType windowType;
};

callback WindowsCreateCallback = void (optional WindowsWindow window);
callback WindowsGetCallback = void (WindowsWindow window);
callback WindowsGetAllCallback = void (sequence&lt;WindowsWindow&gt; windows);
callback WindowsGetCurrentCallback = void (WindowsWindow window);
callback WindowsGetLastFocusedCallback = void (WindowsWindow window);
callback WindowsOnFocusChangedCallback = void (unsigned short windowId);
callback WindowsUpdateCallback = void (WindowsWindow window);

[NoInterfaceObject]
interface BrowserWindows {
    void create(CreateWindowInfo details, Function callback);
    void get(unsigned short, optional GetWindowInfo details, WindowsGetCallback callback);
    void getAll(optional GetWindowInfo details, WindowsGetAllCallback callback);
    void getCurrent(optional GetWindowInfo details, WindowsGetCurrentCallback callback);
    void getLastFocused(optional GetWindowInfo details, WindowsGetLastFocusedCallback callback);
    void onFocusChanged(WindowsOnFocusChangedCallback callback);
    void update(unsigned short windowId, optional WindowUpdateInfo updateInfo, optional WindowsUpdateCallback callback);
};
    
[NoInterfaceObject, Exposed=Window, CheckAnyPermissions="browserextensions"]
interface BrowserWindowsAPI {
readonly attribute BrowserWindows windows; 
};

Browser implements BrowserWindowsAPI;
</pre>
            </section>
        </section>
        <section class='informative'>
            <h3>Native Messaging</h3>
            Native Messaging is covered in another specification. See <a href="https://browserext.github.io/native-messaging/">https://browserext.github.io/native-messaging/</a>.
        </section>

    </section>

    <section class='informative'>
        <h2>Manifest Format</h2>
        <section>
            <h3>Pre-parsing</h3>
            Standards-compliant browsers are expected to ignore "//" comments. Disregarding comments, the manifest.json file format for browser extensions is expected to be fully JSON compliant. Malformed JSON files are not supported.
        </section>
        <section>
            <h3>Permissions URL patterns</h3>
            <p class="issue">TODO: Define how and where these are used</p>
        </section>
        <section>
            <h3>Full Example</h3>
<pre>
// Standards-compliant browsers are expected to ignore "//" comments. Disregarding comments, 
// the manifest.json file format for browser extensions is expected to be fully JSON compliant. 
// Malformed JSON files are not supported.
//
// Other manifest keys that are well-formed JSON but are not listed here must be ignored.
//
// Note that some fields marked as Optional here are required by vendor-specific distribution Stores.
{
  "name": "The Name of Your Extension",             // Required
  "version": "Your Extension Version",              // Required
  "default_locale": "en",                           // Required if locales are used. Otherwise, not allowed

  "description": "Description for Your Extensions",   
  "icons": {...},                                    
  "developer": {                                    
       "name": "Your Name or Company",              
       "url": "Company Website"                      
  }

  // Note: Some browsers require an extension to use either browser_action or page_action, but not both simultaneously
  "browser_action": {  
      "default_icon": {...},                        // Same format as "icons"
      "default_popup": "Page URL",
      "default_title": "Title string"
  },
  "page_action": {...},                             // Same format as "browser_action"
  
  "browser_specific_settings": {                    
       "&lt;browser_name&gt;": {                          // Examples "gecko","opera","edge"
            "&lt;key&gt;": "&lt;value&gt;"                      // Examples "strict_min_version": "42.0", "id": "addon@example.com"
       }
  },

  "background": {                                   
      "page": "Page URL",                           // Only one of "page" or "scripts" may be specified, but not both 
      "scripts": [],                                // Only one of "page" or "scripts" may be specified, but not both 
      "persistent": false                           // Required if "background" is specified
  },

  "content_scripts": {                                                    
      "all_frames": false,                          
      "css": [],                                   
      "exclude_matches": [],                        
      "js": [],                                     
      "matches": [],                                
      "run_at" : "document_start"                   // Also "document_end", "document_idle"
  }

  "content_security_policy": "&lt;policy-string&gt;",     
  
  "options_page": "Page URL",                            // Optional
  "manifest_version": 2,                            // Not used
  "required_keys": [],                              // If a browser does not recognize a key in the list, it must 
                                                    // reject the manifest (e.g. "sidebar_action")
                                                    // Future keys may be required to be in the list if used. 
                                                    // FEEDBACK: Rename to "required_capabilities"
  "permissions": {                                  
       "activeTab",                                                
       "contextMenus",                              
       "storage",                                   
       "tabs",                                      
       "webNavigation",                            
       "webRequest",                                
       "webRequestBlocking",                        
       "&lt;url-pattern&gt;"                              // Examples "http://*/*", "<all_urls>"
  },

  "web_accessible_resources": [...]    

  "externally_connectable" : [
       "ids":[...], // Identifiers for other extensions that are allowed to send messages
       "matches":[...] // URL patterns for hosted web pages allowed to send messages 
  ]                             
}
</pre>
        </section>
    </section>
    <section class='informative'>
        <h2>Extension Resources</h2>
        <section>
            <h3>The <code>browserext://</code> protocol</h3>
            <p>
                To access resources within the extension, such as <code>browserext://&lt;ext_id&gt;/options.html</code>, the <code>browserext://</code> protocol is used.
            </p>
        </section>
        <section>
            <h3>Extension IDs</h3>
            <p>
                Each extension has an extension ID that follows the <code>browserext://</code> protocol. For example
            </p>
            <p class="example">
                <code>browserext://MyExtension_c1wakc4j0nefm/options.html</code>
                <code>browserext://dfcijpibodeoenkablikbkiobbdnkfki/options.html</code>
            </p>
            <p>
                The algorithms that generate these IDs are different for each browser. To access these resources, do not hardcode the ID generated by a particular browser. Instead, use the <code>runtime.getURL()</code> method to convert a relative file name or path to the absolute name or path, which includes the extension ID.
            </p>
        </section>
    </section>
    <section class='informative'>
        <h2>Content Security Polity (CSP)</h2>
        <p class="issue">The default CSP is discussed here <a href="https://www.w3.org/TR/CSP/">https://www.w3.org/TR/CSP/</a></a></p>
    </section>
    <section class='informative'>
        <h2>Testing Extensions with WebDriver</h2>
        <p>
            There are proposed additions to WebDriver that allow for automated testing of extension popups, browser and page actions, and more. This is covered in <a href="http://rawgit.com/dhbrett/webdriver/extensions_reduced/webdriver-spec.html#extensions">another specification</a>.
        </p>
    </section>
    <section class='informative'>
        <h2>Packaging</h2>
        <p>
            Browser extensions may be distributed and subsequently loaded as individual files or via a container, such as a *.zip archive. Regardless of the packaging format, these containers must contain the following:
        </p>
        <ul>
            <li>manifest.json</li>
            <li>Necessary JavaScript files (&lt;filename&gt;.js)</li>
        </ul>
        <section class='informative'><h3>Digital signatures</h3>
            <p class="issue">
                This is TBD.
            </p>
        </section>
    </section>
</body>
</html>
